# # Посмотреть как правильно использовать словарь
# def merge_ist(list1,list2):
#     list3 = []
#     for i in list1:
#         list3.append(i)
#     for i in list2:
#         list3.append(i)
#     list3.sort()
#     return print(list3)
# # подумать как можно сделать  без сортировки.
# # team.sort  - алгоритм сортировки используется по умолчанию.
# Области видимости. Какие  они бывают. Замыкание,  рекурсия, декорат.
# Область видимости существует  глобальная  и локальная.  Все  что  за  пределами функции это глобальные  переменные. Все что в функции это  локальные.
# print(globals(), locals()) - можно проверить
# Метод get подучить
# Ключевое слово global вызов напрмую глобальной переменной
# декораторы(wrapper)
import time
# start = time
# @get_time
# def a():
#     time.sleep(1)
# a()
# def b():
#     time.sleep(2)
# def c():
#     time.sleep(3)
# start =  time.time()
# print(start)
# a()
# b()
# c()
# stop = time.time()
# print(stop)
# print(stop - start)
# Декоратор над оболочкой  функции
#  функция декоратора всегда принимает первым ссылку  на функцию(func - ссыдка на функцию)
# def get_time(func):
#     def wrapper():
#         start = time.time()
#         func()
#         stop = time.time()
#         print(f"Функция выполнилась за {stop - start}")
#     return wrapper
# @get_time
# def a():
#     time.sleep(1)
# Разобраться как  написать декоратор,  который принимает на себя аргументы
# Замыкание (Closure) - это функция в функции
# def multiple(first_num):
#     def mul_2(second_num):
#         return first_num * second_num
#     return mul_2
# nine = multiple(9)
# print(nine(4))
# nonlocal меняет доступ переменной из вышестоящей область видимости, если она не глобальная.
# Замыкание функции - посмотреть что это такое
# рекурсия - функция, которая  вызывает вызов самой себя.
# Решить задачу по числу  фибоначи через  рекурсию
# def sum_nums__until_10(start_num):
#     print(start_num)
#     if start_num == 10:
#         return 10
#     return sum_nums__until_10(start_num + 1)
# print(sum_nums__until_10(10))
# Итератор - объект, который реализует 2 метода __iter__ и __next__. Может доставать объект только один объект. Если пытаться вытащить больше чем объектов в списке.
# Итерируемый объект -  реализует метод __iter__ . Метод __iter__ Можно пройтись функцией for
# после in любой итрируемый объект становится итератором.
# Генератор - это итератор,  который определяется через функцию с ключевым словом yield.
# Если в функции встречается  хоть  одно слово yield - это  генератор,  а в генераторе return не нужно
